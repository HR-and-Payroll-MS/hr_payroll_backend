#!/bin/bash

set -o errexit
set -o pipefail
set -o nounset

# Trap for graceful logging on termination
on_term() {
  echo "START: Received termination signal. Shutting down." >&2
}
trap on_term TERM INT

# Log failing line on any error for better diagnostics
trap 'echo "ERROR: Command failed at line ${LINENO}. See previous logs for context." >&2' ERR

# Optional verbose shell tracing in logs
if [ "${ENABLE_DEBUG_LOGS:-0}" = "1" ]; then
	set -x
fi

ERRORS=0
WARNINGS=0

# Ensure we use production settings unless explicitly overridden
export DJANGO_SETTINGS_MODULE="${DJANGO_SETTINGS_MODULE:-config.settings.production}"

# Startup diagnostics (sanitized); disable by setting STARTUP_DIAGNOSTICS=0
if [ "${STARTUP_DIAGNOSTICS:-1}" = "1" ]; then
python - <<'PY'
import os
from urllib.parse import urlparse
print("=== Startup diagnostics ===")
print("DJANGO_SETTINGS_MODULE:", os.environ.get("DJANGO_SETTINGS_MODULE"))
sk = os.environ.get("DJANGO_SECRET_KEY", "")
print("SECRET_KEY set:", bool(sk), "length:", len(sk) if sk else 0)
db_url = os.environ.get("DATABASE_URL")
if db_url:
	p = urlparse(db_url)
	print(f"DATABASE: scheme={p.scheme} host={p.hostname} port={p.port} name={p.path.lstrip('/')} user={p.username}")
else:
	print("DATABASE_URL not set")
redis_url = os.environ.get("REDIS_URL")
if redis_url:
	r = urlparse(redis_url)
	print(f"REDIS: scheme={r.scheme} host={r.hostname} port={r.port} db={r.path.lstrip('/')}")
else:
	print("REDIS_URL not set")
try:
	from django.conf import settings
	print("ALLOWED_HOSTS:", getattr(settings, 'ALLOWED_HOSTS', []))
	print("DEBUG:", getattr(settings, 'DEBUG', None))
	print("ADMIN_URL:", getattr(settings, 'ADMIN_URL', 'admin/'))
except Exception as e:
	print("Could not import Django settings:", repr(e))
print("============================")
PY
fi

echo "STEP: Django system checks"
if python /app/manage.py check --deploy --fail-level WARNING; then
  echo "OK: System checks completed"
else
  echo "WARN: System checks reported issues (non-fatal)" >&2
  WARNINGS=$((WARNINGS+1))
fi

echo "STEP: Applying migrations"
if python /app/manage.py migrate --noinput; then
  echo "OK: Migrations applied"
else
  echo "ERROR: Migration step failed" >&2
  ERRORS=$((ERRORS+1))
  exit 1
fi

echo "STEP: Collecting static files"
if python /app/manage.py collectstatic --noinput; then
  echo "OK: Static files collected"
else
  echo "ERROR: collectstatic failed" >&2
  ERRORS=$((ERRORS+1))
  exit 1
fi

if python /app/manage.py help | grep -q setup_rbac; then
  echo "STEP: Running setup_rbac"
  if python /app/manage.py setup_rbac; then
    echo "OK: setup_rbac completed"
  else
    echo "WARN: setup_rbac failed (non-fatal)" >&2
    WARNINGS=$((WARNINGS+1))
  fi
else
  echo "INFO: setup_rbac command not present"
fi

# Optionally start sshd (port 2222) for interactive access where supported.
# On platforms like Render this may fail (non-root, restricted env). Make it non-fatal.
if [ "${ENABLE_SSHD:-0}" = "1" ]; then
	if command -v /usr/sbin/sshd >/dev/null 2>&1; then
		if /usr/sbin/sshd -D >/dev/null 2>&1 & then
			echo "OK: sshd started"
		else
			echo "WARN: sshd failed to start (non-fatal)" >&2
			WARNINGS=$((WARNINGS+1))
		fi
	else
		echo "INFO: sshd not available; skipping"
	fi
fi

PORT="${PORT:-5000}"
# Tune Gunicorn for constrained environments (e.g., Render free/low-memory)
# Use WEB_CONCURRENCY or GUNICORN_WORKERS if provided; default to 2.
if [ -n "${WEB_CONCURRENCY:-}" ]; then
	WORKERS="${WEB_CONCURRENCY}"
else
	WORKERS="${GUNICORN_WORKERS:-2}"
fi

TIMEOUT="${GUNICORN_TIMEOUT:-60}"
MAX_REQUESTS="${GUNICORN_MAX_REQUESTS:-1000}"
MAX_REQUESTS_JITTER="${GUNICORN_MAX_REQUESTS_JITTER:-100}"
LOG_LEVEL="${GUNICORN_LOG_LEVEL:-info}"
ACCESS_LOG="${GUNICORN_ACCESS_LOGFILE:--}"
ERROR_LOG="${GUNICORN_ERROR_LOGFILE:--}"
KEEPALIVE="${GUNICORN_KEEPALIVE:-5}"
GRACEFUL_TIMEOUT="${GUNICORN_GRACEFUL_TIMEOUT:-30}"

echo "SUMMARY: warnings=${WARNINGS}, errors=${ERRORS}"
echo "START: Launching Gunicorn with workers=${WORKERS}, timeout=${TIMEOUT}, bind=0.0.0.0:${PORT}"

exec /usr/bin/tini -- /usr/local/bin/gunicorn \
	config.asgi:application \
	--bind 0.0.0.0:"${PORT}" \
	--chdir=/app \
	-k uvicorn.workers.UvicornWorker \
	--workers "${WORKERS}" \
	--timeout "${TIMEOUT}" \
	--graceful-timeout "${GRACEFUL_TIMEOUT}" \
	--keep-alive "${KEEPALIVE}" \
	--max-requests "${MAX_REQUESTS}" \
	--max-requests-jitter "${MAX_REQUESTS_JITTER}" \
	--log-level "${LOG_LEVEL}" \
	--access-logfile "${ACCESS_LOG}" \
	--error-logfile "${ERROR_LOG}"
